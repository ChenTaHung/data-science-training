# Data wrangling with tidyr (tidyverse) {#tidyr} 

```{r wrangling ops, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(htmltools)
```


## `tidyr` overview

Often, data must be reshaped for it to become tidy data. What does that mean? There are four main verbs we'll use, which are essentially pairs of opposites:

- turn columns into rows (`gather()`),
- turn rows into columns (`spread()`),
- turn a character column into multiple columns (`separate()`),
- turn multiple character columns into a single column (`unite()`)

![](img/rstudio-cheatsheet-spread-gather-sep-unite.png)

You use `spread()` and `gather()` to transform or reshape data between 'wide' to 'long' formats. 'long' format is the tidy data we are after, where:

 - each column is a variable
 - each row is an observation

In the 'long' format, you usually have 1 column for the observed variable and the other columns are ID variables.

For the 'wide' format each row is often a site/subject/patient and you have multiple observation variables containing the same type of data. These can be either repeated observations over time, or observation of multiple variables (or a mix of both). Data input may be simpler or some other applications may prefer the 'wide' format. However, many of `R`'s functions have been designed assuming you have 'long' format data. 

These data formats mainly affect readability. For humans, the wide format is often more intuitive since we can often see more of the data on the screen due to it's shape. However, the long format is more machine readable and is closer to the formatting of databases. The ID variables in our dataframes are similar to the fields in a database and observed variables are like the database values.

> Question: Is gapminder a purely long, purely wide, or some intermediate format?

Sometimes, as with the gapminder dataset, we have multiple types of observed data. It is somewhere in between the purely 'long' and 'wide' data formats: 

- 3 "ID variables" (`continent`, `country`, `year`) 
- 3 "Observation variables" (`pop`,`lifeExp`,`gdpPercap`). 

It's pretty common to have data in this intermediate format in most cases despite not having ALL observations in 1 column, since all 3 observation variables have different units. But we can play with switching it to long format and wide to show what that means (i.e. long would be 4 ID variables and 1 Observation variable).

**Note:** Generally, mathematical operations are better in long format, although some plotting functions actually work better with wide format.


### Install `tidyr`, investigate gapminder data

First install and load `tidyr`:
```{r,message=FALSE}
#install.packages("tidyr")
library("tidyr") # warning messages are OK
```

## From wide to long format with `gather()`

`r img(src='img/rstudio-cheatsheet-reshaping-data-gather.png', width=500)` 

We've been working with pretty tidy data. So for practice, now let's work with these data in a wider format, maybe the way you or your colleague entered it in a spreadsheet. We'll work with it to get it back to the way we like it.
```{r, eval=FALSE}
gap_wide <- read.csv('data/gapminder_wide.csv')
```

```{r, eval=FALSE}
head(gap_wide)
str(gap_wide)
```

While wide format is nice for data entry, it's not nice for calculations. What if you were asked for the mean population after 1990 in Algeria? Possible, but ugly. Let's tidy it back to the intermediate format we've been using. 

> Question: let's talk this through together. If we're trying to turn the `gap_wide` format into `gapminder` format, what structure does it have that we like? And that we want to change?

- We like the continent and country columns. We won't want to change those. 
- For long format, we'd want just 1 column identifying the variable name (`tidyr` calls this a **'key'**), and 1 column for the data (`tidyr` calls this the '**value'**).
- For intermediate format, we'd want 3 columns for `gdpPercap`, `lifeExp`, and `pop`.
- We would like year as a separate column. 

Let's get it to long format. We'll have to do this in 2 steps. The first step is to take all of those column names and make them a variable in a new column, and transfer the values into another column. 

Let's have a look at `gather()`'s help: 
```{r, eval=FALSE}
?gather
```

> Question: What is our **key-value pair**? 

We need to name two new variables in the key-value pair, one for the key, one for the value. Let's name them `obstype_year` and `obs_value`.  

Here's the start of what we'll do: 
```{r, eval=FALSE}
gap_long <- gap_wide %>% 
  gather(key   = obstype_year,
         value = obs_values)
```
```{r, eval=FALSE}
str(gap_long)
head(gap_long)
tail(gap_long)
```
So this has reshaped our dataframe, but really not how we wanted. Very important to check, and listen to that warning message--dropping attributes seems very suspicious. Like suspenders.

What went wrong? Notice that it didn't know that we wanted to keep `continent` and `country` untouched; we need to give it more information about which columns we want reshaped. We can do this in several ways.

One way: identify the column numbers you want to use. Not ideal because column numbers could change, but it does exactly what we want! And illustrates it nicely.
```{r, eval=FALSE}
gap_long <- gap_wide %>% 
  gather(key   = obstype_year,
         value = obs_values,
         3:38)  # could also do -1, -2: 'not column one, not column two
str(gap_long)
head(gap_long)
tail(gap_long)
```

Better way: identify the columns by name. Listing them out by explicit name can be a good approach if there are a few. But I'm not going to list them out here, and way too much potential for error if you tried gdpPercap_1952, gdpPercap_1957, gdpPercap_1962... So let's use some of `dplyr`'s awesome helper functions. 
```{r, eval=FALSE}
gap_long <- gap_wide %>% 
  gather(key   = obstype_year,
         value = obs_values,
         dplyr::starts_with('pop'),
         dplyr::starts_with('lifeExp'),
         dplyr::starts_with('gdpPercap'))
str(gap_long)
head(gap_long)
tail(gap_long)
```
Success! And you could also do it this way. 

```{r, eval=FALSE}
gap_long <- gap_wide %>% 
  gather(key   = obstype_year,
         value = obs_values,
         -continent, -country)
str(gap_long)
head(gap_long)
tail(gap_long)
```
To recap: 

Inside `gather()` we first name the new column for the new ID variable (`obstype_year`), the name for the new amalgamated observation variable (`obs_value`), then the names of the old observation variable. We could have typed out all the observation variables, but as in the `select()` function (see `dplyr` lesson), we can use the `starts_with()` argument to select all variables that starts with the desired character string. Gather also allows the alternative syntax of using the `-` symbol to identify which variables are not to be gathered (i.e. ID variables)

OK, but we're not done yet. `obstype_year` actually contains 2 pieces of information, the observation type (`pop`,`lifeExp`, or `gdpPercap`) and the `year`. We can use the `separate()` function to split the character strings into multiple variables

`?separate` --> we'll tell it which column we want separated, name new columns that we want to create, and tell it what we want it to separate by. Since the `obstype_year` variable has observation types and years separated by a `_`, we'll use that. 
```{r, eval=FALSE}
gap_long <- gap_wide %>% 
  gather(key   = obstype_year,
         value = obs_values,
         -continent, -country) %>%
  separate(obstype_year,
           into = c('obs_type','year'),
           sep="_")
```
```{r, eval=FALSE}
str(gap_long)
head(gap_long)
tail(gap_long)
```
Excellent. This is long format: every row is a unique observation. Yay!

> Exercise: Using `gap_long`, calculate the mean life expectancy, population, and gdpPercap for each continent. **Hint:** use the `group_by()` and `summarize()` functions we learned in the `dplyr` lesson

```{r, eval=FALSE}
# solution (no peeking!)
gap_long %>% 
  group_by(continent, obs_type) %>%
    summarize(means = mean(obs_values))
```

## From long to intermediate format with `spread()`

![](img/rstudio-cheatsheet-reshaping-data-spread.png)

Now just to double-check our work, let's use the opposite of `gather()` to spread our observation variables back to the original format with the aptly named `spread()`. You pass `spread()` the key and value pair, which is now `obs_type` and `obs_values`.
```{r, eval=FALSE}
gap_normal <- gap_long %>% 
  spread(obs_type, obs_values)
```
```{r, eval=FALSE}
dim(gap_normal)
dim(gapminder)
names(gap_normal)
names(gapminder)
```

Now we've got an intermediate dataframe `gap_normal` with the same dimensions as the original `gapminder`, but the order of the variables is different. Let's fix that before checking if they are `all.equal()`.

> Exercise: reorder the columns in gap_normal to match gapminder. 

```{r, eval=FALSE}
# Solution, no peeking!

# one way with dplyr (also nice because can chain this from gap_normal creation)
gap_normal <- gap_normal %>%
  select(country, continent, year, lifeExp, pop, gdpPercap)

# another way with base R
gap_normal <- gap_normal[,names(gapminder)]
```

Now let's check if they are all.equal (`?all.equal`) is a handy test
```{r, eval=FALSE}
all.equal(gap_normal,gapminder)
```
```{r, eval=FALSE}
head(gap_normal)
head(gapminder)
```

We're almost there, the original was sorted by `country`, `continent`, then `year`.
```{r, eval=FALSE}
gap_normal <- gap_normal %>% arrange(country,continent,year)
all.equal(gap_normal,gapminder)
```
```{r, eval=FALSE}
str(gap_normal)
str(gapminder)
```
Mine shows a slight difference because one is a data.frame and one is a tbl_df, which is similar to a data.frame. We won't get into this difference now, I'm feeling good about these data sets! We've gone from the longest format back to the intermediate and we didn't introduce any errors in our code.

> Exercise: convert gap_long all the way back to gap_wide. Hint: you'll need to create appropriate labels for all our new variables (time*metric combinations) with `tidyr::unite()`. 

```{r, eval=FALSE}
# Solution, no peeking: 
head(gap_long) # remember the columns

gap_wide_new <- gap_long %>% 
  # first unite obs_type and year into a new column called var_names. Separate by _
  unite(col = var_names, obs_type, year, sep = "_") %>% 
  # then spread var_names out by key-value pair.
  spread(key = var_names, value = obs_values)
str(gap_wide_new)
```

### clean up and save your .r script

Spend some time cleaning up and saving `gapminder-wrangle.r`
Restart R. In RStudio, use *Session > Restart R*. Otherwise, quit R with `q()` and re-launch it.

Your final R script could look something like this: 

```{r, eval=FALSE}

## install, load dplyr
#install.packages("dplyr") ## do this once only to install the package on your computer.
library(dplyr)

## load gapminder
library(gapminder) # this is the package name
str(gapminder) # there's still a data frame named 'gapminder'

## practice dplyr::filter()
filter(gapminder, lifeExp < 29)
filter(gapminder, country == "Mexico")
filter(gapminder, country %in% c("Mexico", "Afghanistan"))

## base R alternatives to dplyr::filter()
gapminder[gapminder$lifeExp < 29, ] ## repeat `gapminder`, [i, j] indexing is distracting
subset(gapminder, country == "Mexico") ## almost same as filter ... but wait ...

## pipe operator %>%
gapminder %>% head # this...
head(gapminder) # ...is the same as this!
gapminder %>% head(3) # can pass arguments! this...
head(gapminder, 3) # ...is the same as this!

## practice dplyr::select() with %>%
select(gapminder, year, lifeExp) # this...
gapminder %>% select(year, lifeExp) # ...is the same as this!

## practice with %>% chains
gapminder %>%
  select(year, lifeExp) %>% 
  head(4) # doesn't have to be a dplyr function

gapminder %>%
  filter(country == "Cambodia") %>%
  select(-continent, -lifeExp) # same as select(country, year, pop, gdpPercap) 

# compare to base R, hard to read!
gapminder[gapminder$country == "Cambodia", c("country", "year", "pop", "gdpPercap")]
subset(gapminder, country == "Cambodia", select = c(country, year, pop, gdpPercap))

## dplyr::mutate() adds new columns
gapminder %>%
  filter(country == "Cambodia") %>%
  select(-continent, -lifeExp) %>%
  mutate(gdp = pop * gdpPercap)

## dplyr::summarize() or summarise() adds new column when grouping
gapminder %>%
  filter(country == "Cambodia") %>%
  select(-continent, -lifeExp) %>%
  mutate(gdp = pop * gdpPercap) %>%
  group_by(country) %>%
  summarize(mean_gdp = mean(gdp)) %>%
  ungroup() # if you use group_by, also use ungroup() to save heartache later

## summarize for all countries (replaces our for loop!)
gapminder %>%
  select(-continent, -lifeExp) %>%
  mutate(gdp = pop * gdpPercap) %>%
  group_by(country) %>%
  summarize(mean_gdp = mean(gdp)) %>%
  ungroup() # if you use group_by, also use ungroup() to save heartache later

## install tidyr
install.packages("tidyr")
library(tidyr)

## load wide data
gap_wide <- read.csv('data/gapminder_wide.csv')
head(gap_wide)
str(gap_wide)

## practice tidyr::gather() wide to long
gap_long <- gap_wide %>% 
  gather(key   = obstype_year,
         value = obs_values,
         -continent, -country) 
# or 
gap_long <- gap_wide %>% 
  gather(key   = obstype_year,
         value = obs_values,
         dplyr::starts_with('pop'),
         dplyr::starts_with('lifeExp'),
         dplyr::starts_with('gdpPercap'))
# or (but always be wary of numerics because they could change silently)
gap_long <- gap_wide %>% 
  gather(key   = obstype_year,
         value = obs_values,
         3:38)  # could also do -1, -2: 'not column one, not column two


## gather() and separate() to create our original gapminder
gap_long <- gap_wide %>% 
  gather(key   = obstype_year,
         value = obs_values,
         -continent, -country) %>%
  separate(obstype_year,
           into = c('obs_type','year'),
           sep="_")

## practice: can still do calculations in long format
gap_long %>% 
  group_by(continent, obs_type) %>%
  summarize(means = mean(obs_values))

## spread() from normal to wide
gap_normal <- gap_long %>% 
  spread(obs_type, obs_values) %>%
  select(country, continent, year, lifeExp, pop, gdpPercap)
# or 
gap_normal <- gap_long %>% 
  spread(obs_type, obs_values)
gap_normal <- gap_normal[,names(gapminder)]

## check that all.equal()
all.equal(gap_normal,gapminder)

## unite() and spread(): convert gap_long to gap_wide
head(gap_long) # remember the columns

gap_wide_new <- gap_long %>% 
  # first unite obs_type and year into a new column called var_names. Separate by _
  unite(col = var_names, obs_type, year, sep = "_") %>% 
  # then spread var_names out by key-value pair.
  spread(key = var_names, value = obs_values)
str(gap_wide_new)
```

### Other tidyr awesomeness 

- `complete()`

------


## Other links

* [Tidying up Data - Env Info](http://ucsb-bren.github.io/env-info/wk04_tidyr.html) - [Rmd](https://github.com/ucsb-bren/env-info/blob/gh-pages/wk04_tidyr.Rmd)
* [Data wrangling with dplyr and tidyr - Tyler Clavelle & Dan Ovando](http://bbest.github.io/dplyr-tidyr-tutorial/) - [Rmd](https://github.com/bbest/dplyr-tidyr-tutorial/blob/gh-pages/index.Rmd)



## Troubleshooting