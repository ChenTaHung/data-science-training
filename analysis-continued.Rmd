# Analysis, continued {#analysis}

## Objectives and Resources

**Objectives**

exposure and lots of practice: 

- importing and writing data
- for loops 
    - save ggplot figs http://r4ds.had.co.nz/iteration.html
- if statements (conditionals) 
    - write message() to yourself
- strings and filenames: 
    - Jenny Bryan pres, list.files(), file.path()
    - stringr() http://r4ds.had.co.nz/strings.html
- installing packages from github
- also mention: lubridate, purrr (don't get into them)


**Resources**

When trying to see if a number or text is equal to some *single* value, use `==`. To check it against *multiple* values, use `%in%`. mineâ€™s "%!in%" <- Negate("%in%")

list.files
file.path()
message() (with an if statement maybe)
get file extensions https://stat.ethz.ch/R-manual/R-devel/library/tools/html/fileutils.html

- installing packages from github
- left_join

You'll soon have questions that are outside the scope of this workshop, how do you find answers?


## Importing data

TODO

Remember you'll use `install.packages("package-name-in-quotes")` and then `library(package-name)`, and then you can explore the help or vignettes. And also, of course, Google to see how to use them!

- `readr` to read in .csv files
- `readxl` to read in Excel files
- `stringr` to work with strings
- `lubridate` to work with dates


purrr:: LOVE LISTS
- more efficient than for loops
- plays nicely with pipes
repurrsive

Show how piping can be used in normal model fitting too (get away from nested stuff)


## Repeating operations with for loops

Let's say we want to subset a few countries and plot pop through time. We could do it the way above, which would look like the following: 
```{r, eval=FALSE}
## plot population of some countries
mexico <- subset(gapminder, subset = country == "Mexico")
plot(mexico$year, mexico$pop)
dev.print(pdf, "mexico.pdf")

panama <- subset(gapminder, subset = country == "Panama") 
plot(panama$year, panama$pop)
dev.print(pdf, "panama.pdf")

ecuador <- subset(gapminder, subset = country == "Ecuador")
plot(ecuador$year, ecuador$pop)
dev.print(pdf, "ecuador")
```

But you can see already it's a lot of text, which means typo-prone and hard to read. Even if you copy-paste each one, there's a lot of copy-paste, and is very typo-prone. Plus, what if you wanted to instead plot lifeExp? You'd have to remember to change it each time...it gets messy quick. And we're just doing it with 3 countries here; what if we wanted to do it to all 142 countries? Eek. 


Better with a for loop. This will let us cycle through and do what we want to each thing in turn. If you want to iterate over a set of values, and perform the same operation on each, a `for` loop will do the job.

The basic structure of a `for` loop is:
```{r, eval=FALSE}
for(iterator in set of values){
  do a thing
}
```

Let's paste from what we had before, and modify it. Also, the `set of values` is the list of countries (`country_list`), and we want to iterate through each country (let's spell it `cntry` so it's distinctive). 
```{r, eval=FALSE}
for (cntry in country_list) {
  mexico <- subset(gapminder, subset = country == "Mexico") 
  plot(mexico$year, mexico$pop)
} 
```

We can't call it mexico anymore, but we could call it something more general. And let's comment the plot() line out while we build this, and add a print statement to see if it's behaving like we think it is. 
```{r, eval=FALSE}
for (cntry in country_list) {
  cntry_subset <- subset(gapminder, subset = country == cntry)  
  # plot(mexico$year, mexico$pop)
  print(cntry_subset)
} 
```

> Question: what is the variable `cntry_subset` right now, after running the for loop? 

Is this doing what we think it's doing? Let's create the country list and print the results each time to test our progress: 
```{r, eval=FALSE}
country_list <- c("Mexico", "Panama", "Ecuador") # identify the thing to loop through
for (cntry in country_list) {
  cntry_subset <- subset(gapminder, subset = country == cntry)  
  # plot(mexico$year, mexico$pop)
  print(cntry_subset)
} 
```

Excellent. Let's move on with the plot. 
```{r, eval=FALSE}
country_list <- c("Mexico", "Panama", "Ecuador") 
for (cntry in country_list) {
  cntry_subset <- subset(gapminder, subset = country == cntry) 
  plot(cntry_subset$year, cntry_subset$pop)
  dev.print(pdf, paste0(cntry,".pdf")) # ?paste0() will paste a string
} 
```

Great! And it doesn't matter if we just use these three countries or all the countries--let's try it. 

First let's create a figure directory and make sure it saves there since it's going to get out of hand quickly: 
```{r, eval=FALSE}
dir.create('figures') # this will be: software-carpentry/figures

country_list <- unique(gapminder$country) # ?unique() returns the unique values
for (cntry in country_list) {
  cntry_subset <- subset(gapminder, subset = country == cntry) 
  plot(cntry_subset$year, cntry_subset$pop)
  dev.print(pdf, paste0("figures/", cntry,".pdf")) # don't forget the `/`: it's a path!
} 
```

So that took a little longer than just the 3, but still super fast. For loops are sometimes just the thing you need to iterate over many things in your analyses. 

Now let's say we also want to record the mean population of each country. We'd add a line to the for loop, and comment out all the plotting for now (to save time, you could also just leave it): 
```{r, eval=FALSE}
dir.create('figures') # this will be: software-carpentry/figures

country_list <- unique(gapminder$country) 
for (cntry in country_list) {
  cntry_subset <- subset(gapminder, subset = country == cntry) 
  # plot(cntry_subset$year, cntry_subset$pop)
  # dev.print(pdf, paste0("figures/", cntry,".pdf"))
  
  pop_mean <- mean(cntry_subset$pop)
  print(paste('mean pop for', cntry, 'is', pop_mean))
} 
```

We know it worked since it printed correctly. But we didn't capture it: `cntry_subset` is just Zimbabwe. Let's create an object outside the loop and add to it each time. 
```{r, eval=FALSE}
dir.create('figures') # this will be: software-carpentry/figures

country_list <- unique(gapminder$country) # ?unique() returns the unique values
country_pop_mean <- data.frame()

for (cntry in country_list) {
  cntry_subset <- subset(gapminder, subset = country == cntry) 
  # plot(cntry_subset$year, cntry_subset$pop)
  # dev.print(pdf, paste0("figures/", cntry,".pdf")) 
  
  pop_mean <- mean(cntry_subset$pop)
  # print(paste('mean pop for', cntry, 'is', pop_mean))
  country_pop_mean <- rbind(country_pop_mean, data.frame(cntry, pop_mean))
} 
```
This approach can be useful, but 'growing your results' (building
the result object incrementally) is computationally inefficient, so avoid
it when you are iterating through a lot of values.

For loops can also lead to temporary variables that you don't need. But they can be really useful at times. 

## conditional statements with `if` and `else`

Often when we're coding we want to control the flow of our actions. This can be done
by setting actions to occur only if a condition or a set of conditions are met.
```{r, eval=FALSE}
# if
if (condition is true) {
  do something
}

# if ... else
if (condition is true) {
  do something
} else {  # that is, if the condition is false,
  do something different
}
```

Say, for example, that in addition to saving population figures for all countries, we want to save life expectancy figures for countries in Asia only. 
```{r, eval=FALSE}
dir.create('figures') # this will be: software-carpentry/figures

country_list <- unique(gapminder$country) # ?unique() returns the unique values
country_pop_mean <- data.frame()
for (cntry in country_list) {
  cntry_subset <- subset(gapminder, subset = country == cntry) 
  # plot(cntry_subset$year, cntry_subset$pop)
  # dev.print(pdf, paste0("figures/", cntry,".pdf")) 
  
  pop_mean <- mean(cntry_subset$pop)
  # print(paste('mean pop for', cntry, 'is', pop_mean))
  country_pop_mean <- rbind(country_pop_mean, data.frame(cntry, pop_mean))
  
  ## if Asia, calculate mean(lifeExp)
  if (unique(cntry_subset$continent) == "Asia") { # read: if (the continent is Asia) {then}
    plot(cntry_subset$year, cntry_subset$lifeExp) 
    dev.print(pdf, paste0("figures/", cntry, "_lifeExp.pdf")) # change the filename
  }
} 
```


And if the country is in Africa, let's plot the mean GDP. 
```{r, eval=FALSE}
dir.create('figures') # this will be: software-carpentry/figures

country_list <- unique(gapminder$country) # ?unique() returns the unique values
country_pop_mean <- data.frame()
for (cntry in country_list) {
  cntry_subset <- subset(gapminder, subset = country == cntry) 
  # plot(cntry_subset$year, cntry_subset$pop)
  # dev.print(pdf, paste0("figures/", cntry,".pdf")) 
  
  pop_mean <- mean(cntry_subset$pop)
  # print(paste('mean pop for', cntry, 'is', pop_mean))
  country_pop_mean <- rbind(country_pop_mean, data.frame(cntry, pop_mean))
  
  ## if Asia, calculate mean(lifeExp)
  if (unique(cntry_subset$continent) == "Asia") { # read: if (the continent is Asia) {then}
    plot(cntry_subset$year, cntry_subset$lifeExp) 
    dev.print(pdf, paste0("figures/", cntry, "_lifeExp.pdf")) 
  } else if (unique(cntry_subset$continent) == "Africa") {
    plot(cntry_subset$year, cntry_subset$gdpPercap) 
    dev.print(pdf, paste0("figures/", cntry, "_gdpPercap.pdf")) # change the filename
  }
} 
```


### TODO: variable classes?

Let's explore a numeric variable: life expectancy.
```{r, eval=FALSE}
## explore numeric variable
summary(gapminder$lifeExp)
hist(gapminder$lifeExp)
```

Let's explore a categorical variable (stored as a *factor* in R): continent.
```{r, eval=FALSE}
## explore factor variable
summary(gapminder$continent)
levels(gapminder$continent)
nlevels(gapminder$continent)
hist(gapminder$continent) # whaaaa!?
```
This error is because of what factors are 'under the hood': R is really storing integer codes 1, 2, 3 here, but represent them as text to us. Factors can be problematic to us because of this, but you can learn to navigate with them. There are resources to learn how to [properly care and feed for factors](http://stat545.com/block014_factors.html).

One thing you'll learn is how to visualize factors with which functions/packages.
```{r, eval=FALSE}
class(gapminder$continent) # ?class returns the class type of the object
table(gapminder$continent) # ?table builds a table based on factor levels 
class(table(gapminder$continent)) # this has morphed the factor...
hist(table(gapminder$continent)) # so we can plot!
```
I don't want us to get too bogged down with what's going on with `table()` and plotting factors, but I want to expose you to these situations because you will encounter them. Googling the error messages you get, and knowing how to look for good responses is a critical skill. (I tend to look for responses from stackoverflow.com that are recent and have green checks, and ignore snarky comments). 

> Exercise with your neighbor: Explore `gapminder$gdpPercap`. What kind of data is it? So which commands do you use? 




