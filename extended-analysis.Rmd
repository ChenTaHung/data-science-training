# Extended analysis {#analysis}

## Objectives and Resources

Do a little analysis: loop through and make figs, save them each.

**Objectives**

- discuss good filenaming practices
- create an R script
- for loops
- if statements
- for loops introduce R Script
    - save ggplot figs (also using stringr, paste())
    - file.path() http://r4ds.had.co.nz/iteration.html
- make sure your loop worked like you wanted
- if statements (conditionals) 
    - write message() to yourself
    - list.files()
- importing and writing data
    - write a local copy of gapminder data to data/ folder
    - installing packages from github

- also mention: lubridate, purrr (don't get into them)






**Resources**

When trying to see if a number or text is equal to some *single* value, use `==`. To check it against *multiple* values, use `%in%`. mineâ€™s "%!in%" <- Negate("%in%")

list.files
file.path()
message() (with an if statement maybe)
get file extensions https://stat.ethz.ch/R-manual/R-devel/library/tools/html/fileutils.html

- left_join

## Naming files

Now is a good interlude to talk about naming things. 

We are going to take five minutes to talk through [Jenny Bryan's three principles for naming files](https://speakerdeck.com/jennybc/how-to-name-files):

1. machine readable
1. human readable
1. play well with default ordering

## Analysis plan

OK, here is the plan for our analysis. We want to plot the gdpPercap for each country in the gapminder data frame. We will label each one and save it in a folder called figures. We will learn a bunch of things as we go. 


## Create an R script

OK, now, we are going to create an R script. What is an R script? It's a text file with a .R extension. We've been writing R code in R Markdown files so far; R scripts are just R code without the Markdown along with it. 

Go to File > New File > R Script (or click the green plus in the top left corner). 

Let's start off with a few comments so that we know what it is for, and save it:

```
## gapminder-analysis.R
## analysis with gapminder data
## J Lowndes lowndes@nceas.uscb.edu
```

We'll be working with the gapminder data again so let's read it in here: 

```{r, message=FALSE}
## load libraries
library(tidyverse)

## read in gapminder data
gapminder <- readr::read_csv('https://raw.githubusercontent.com/OHI-Science/data-science-training/master/data/gapminder.csv')

```

Remember, like in R Markdown, hitting return does not execute this command. To execute it, we need to get what we typed in the script down into the console. Here is how we can do that:

1. copy-paste this line into the console.
2. select the line (or simply put the cursor there), and click 'Run'. This is available from 
    a. the bar above the script (green arrow)
    b. the menu bar: Code > Run Selected Line(s)
    c. keyboard shortcut: command-return
3. source the script, which means running the whole thing. This is also great for to see if there are any typos in your code that you've missed. You can do this by:
    a. clicking Source (blue arrow in the bar above the script).
    b. typing `source('gapminder-analysis.R')` in the console (or from another R file!!!). 

## Automation with for loops

Our plan is to plot gdpPercap for each country. This means that we want to do the same operation (plotting gdpPercap) on a bunch of different things (countries). Yesterday we learned the dplyr's `group_by()` function, and this is super powerful to automate through groups. But there are things that `group_by()` can't do, like plotting. So we will use a for loop.

Let's start off with what this would look like for just one country. I'm going to demonstrate with Afghanistan:

<!---TODO
For the figures, we want it to label the currency, which we have in another data file (=join). And, we'll want to add Westeros to the dataframe (=rbind) and create that figure too. 
--->

```{r}
## filter the country to plot
gap_to_plot <- gapminder %>%
  filter(country == "Afghanistan")

## plot
ggplot(data = gap_to_plot, aes(x = year, y = gdpPercap)) + 
  geom_point() +
  labs(title = "Afghanistan")
```

Let's actually give this a better title than just the country name. Let's use the `base::paste()` function from to paste two strings together so that the title is more descriptive. Use `?paste` to see what the "sep" variable does. 
```{r}
## filter the country to plot
gap_to_plot <- gapminder %>%
  filter(country == "Afghanistan")

## plot
ggplot(data = gap_to_plot, aes(x = year, y = gdpPercap)) + 
  geom_point() +
  ## add title and save
  labs(title = paste("Afghanistan", "GDP per capita", sep = " "))
```

And as a last step, let's save this figure using `base::file.path()` (which works like paste() would if sep = "/"). 
```{r}
## filter the country to plot
gap_to_plot <- gapminder %>%
  filter(country == "Afghanistan")

## plot
ggplot(data = gap_to_plot, aes(x = year, y = gdpPercap)) + 
  geom_point() +
## add title and save
  labs(title = paste("Afghanistan", "GDP per capita", sep = " ")) +
  ggsave(filename = "Afghanistan_gdpPercap.png",
         width = 15, height = 10)
```

OK. So we can check in our figures/folder and see that this works well. And there wasn't that much code needed to get us here, but we definitely do not want to copy this for every country. Even if we copy-pasted and switched out the names, it would be very typo-prone. Plus, what if you wanted to instead plot lifeExp? You'd have to remember to change it each time...it gets messy quick. 

Better with a for loop. This will let us cycle through and do what we want to each thing in turn. If you want to iterate over a set of values, and perform the same operation on each, a `for` loop will do the job.

### Basic structure

The basic structure of a `for` loop is:
```{r, eval=FALSE}
for( each item in set of items ){
  do a thing
}
```
Note the `( )` and the `{ }`. We talk about iterating through each item in the for loop, which makes each item an iterator.

So looking back at our Afghanistan code: all of this is pretty much the "do a thing" part. And we can see that there are only a few places that are specific to Afghanistan. If we could make those places not specific to Afghanistan, we would be set. 

![](img/for_loop_logic.png)

Let's paste from what we had before, and modify it. I'm also going to use RStudio's identation help to indent the lines within the for loop by highlighting the code in this chunk and going to Code > Reindent Lines (shortcut: command I)
```{r, eval=FALSE}
for( each item in set of items ){
  
  ## filter the country to plot
  gap_to_plot <- gapminder %>%
    filter(country == "Afghanistan")
  
  ## plot
  ggplot(data = gap_to_plot, aes(x = year, y = gdpPercap)) + 
    geom_point() +
    ## add title and save
    labs(title = paste("Afghanistan", "GDP per capita", sep = " ")) +
    ggsave(filename = "Afghanistan_gdpPercap.png",
           width = 15, height = 10)
} 
```

OK. So let's start with the beginning of the for loop. We want a list of countries that we will iterate through. We can do that by adding this code before the for loop. And we will need to name the iterator something, so let's call it cntry so that it has a distinct name. 

We can also add a print statement so that we can watch it iterate:
```{r, eval=FALSE}
## create a list of countries
country_list <- c("Albania", "Fiji", "Spain")

for( cntry in country_list ){
  
  ## filter the country to plot
  gap_to_plot <- gapminder %>%
    filter(country == "Afghanistan")
  
  ## add a print message 
  print(paste("Plotting ", cntry))
  
  ## plot
  ggplot(data = gap_to_plot, aes(x = year, y = gdpPercap)) + 
    geom_point() +
    ## add title and save
    labs(title = paste("Afghanistan", "GDP per capita", sep = " ")) +
    ggsave(filename = "Afghanistan_gdpPercap.png",
           width = 15, height = 10)
} 
```

At this point, we do have a functioning for loop. For each item in the `country_list$country`, the for loop will iterate over the code within the `{ }`, changing `cntry` each time as it goes through the list. And we can see it works because our print statement displays each country. 

But our code doesn't work the way we expected. Why? Well, is looping through the 3 countries in our country_list, but it is creating plots for Afghanistan each time. We can see that by looking in the git tab: only that one Afghanistan figure. It's because we haven't brought the `cntry` variable into the for loop. Let's do that now. 

### Functioning for loop

```{r, eval=FALSE}
## create a list of countries
country_list <- c("Albania", "Fiji", "Spain") 

for( cntry in country_list ){
  
  ## filter the country to plot
  gap_to_plot <- gapminder %>%
    filter(country == cntry)
  
  ## add a print message 
  print(paste("Plotting ", cntry))
  
  ## plot
  ggplot(data = gap_to_plot, aes(x = year, y = gdpPercap)) + 
    geom_point() +
    ## add title and save
    labs(title = paste(cntry, "GDP per capita", sep = " ")) +
    ggsave(filename = paste(cntry, "_gdpPercap.png", sep = ""), 
           width = 15, height = 10)
} 
```


Great! And it doesn't matter if we just use these three countries or all the countries--let's try it. 

But first let's create a figure directory and make sure it saves there since it's going to get out of hand quickly. We could do this from the Finder/Windows Explorer, or from the "Files" pane in RStudio by clicking "New Folder" (green plus button). But we are going to do it in R. A folder is called a directory:

```{r, eval=FALSE}
dir.create("figures") 

## create a list of countries
country_list <- unique(gapminder$country) # ?unique() returns the unique values

for( cntry in country_list ){
  
  ## filter the country to plot
  gap_to_plot <- gapminder %>%
    filter(country == cntry)
  
  ## add a print message 
  print(paste("Plotting ", cntry))
  
  ## plot
  ggplot(data = gap_to_plot, aes(x = year, y = gdpPercap)) + 
    geom_point() +
    ## add title and save
    labs(title = paste(cntry, "GDP per capita", sep = " ")) +
    ggsave(filename = paste("figures/", cntry, "_gdpPercap.png", sep = ""), 
           width = 15, height = 10)
} 
```

So that took a little longer than just the 3, but still super fast. For loops are sometimes just the thing you need to iterate over many things in your analyses. 

### Clean up our repo

OK we now have 142 figures that we just created. They exist locally on our computer, and we have the code to recreate them anytime. But, we don't really need to push them to GitHub. Let's delete the figures/ folder and see it disappear from the Git tab. 

### Your turn

1. Modify our for loop so that it loops through countries in Europe only, and saves them to a new subfolder inside the (recreated) figures folder called "Europe". 
1. Sync to GitHub

#### Answer

## Conditional statements with `if` and `else` 

Often when we're coding we want to control the flow of our actions. This can be done
by setting actions to occur only if a condition or a set of conditions are met.
```{r, eval=FALSE}
# if
if (condition is true) {
  do something
}

# if ... else
if (condition is true) {
  do something
} else {  # that is, if the condition is false,
  do something different
}
```

Say, for example, that in addition to saving population figures for all countries, we want to save life expectancy figures for countries in Asia only. 
```{r, eval=FALSE}
dir.create('figures') # this will be: software-carpentry/figures

country_list <- unique(gapminder$country) # ?unique() returns the unique values
country_pop_mean <- data.frame()
for (cntry in country_list) {
  cntry_subset <- subset(gapminder, subset = country == cntry) 
  # plot(cntry_subset$year, cntry_subset$pop)
  # dev.print(pdf, paste0("figures/", cntry,".pdf")) 
  
  pop_mean <- mean(cntry_subset$pop)
  # print(paste('mean pop for', cntry, 'is', pop_mean))
  country_pop_mean <- rbind(country_pop_mean, data.frame(cntry, pop_mean))
  
  ## if Asia, calculate mean(lifeExp)
  if (unique(cntry_subset$continent) == "Asia") { # read: if (the continent is Asia) {then}
    plot(cntry_subset$year, cntry_subset$lifeExp) 
    dev.print(pdf, paste0("figures/", cntry, "_lifeExp.pdf")) # change the filename
  }
} 
```


Now let's say we also want to record the mean population of each country. We'd add a line to the for loop, and comment out all the plotting for now (to save time, you could also just leave it): 
```{r, eval=FALSE}
dir.create('figures') # this will be: software-carpentry/figures

country_list <- unique(gapminder$country) 
for (cntry in country_list) {
  cntry_subset <- subset(gapminder, subset = country == cntry) 
  # plot(cntry_subset$year, cntry_subset$pop)
  # dev.print(pdf, paste0("figures/", cntry,".pdf"))
  
  pop_mean <- mean(cntry_subset$pop)
  print(paste('mean pop for', cntry, 'is', pop_mean))
} 
```

We know it worked since it printed correctly. But we didn't capture it: `cntry_subset` is just Zimbabwe. Let's create an object outside the loop and add to it each time. 
```{r, eval=FALSE}
dir.create('figures') # this will be: software-carpentry/figures

country_list <- unique(gapminder$country) # ?unique() returns the unique values
country_pop_mean <- data.frame()

for (cntry in country_list) {
  cntry_subset <- subset(gapminder, subset = country == cntry) 
  # plot(cntry_subset$year, cntry_subset$pop)
  # dev.print(pdf, paste0("figures/", cntry,".pdf")) 
  
  pop_mean <- mean(cntry_subset$pop)
  # print(paste('mean pop for', cntry, 'is', pop_mean))
  country_pop_mean <- rbind(country_pop_mean, data.frame(cntry, pop_mean))
} 
```
This approach can be useful, but 'growing your results' (building
the result object incrementally) is computationally inefficient, so avoid
it when you are iterating through a lot of values.

For loops can also lead to temporary variables that you don't need. But they can be really useful at times. 

## Here





```{r, eval=FALSE}

gapminder <- readr::read_csv('https://raw.githubusercontent.com/OHI-Science/data-science-training/master/data/gapminder.csv')

## filter the of countries in Europe
countries_europe <- gapminder %>% 
  filter(continent == "Europe") %>%
  select(country) %>%
  distinct() 

## create a folder for figures
dir.create("figures")

## iterate through each country
for (cntry in countries_europe$country) { # cntry = "Albania"
 
  ## filter each iteration
  gap_cntry <- gapminder %>%
    filter(country == cntry)
  
  ## plot
  ggplot(data = gap_cntry, aes(x = year, y = gdpPercap)) + 
    geom_point() + 
    
    ## labels
    labs(title = paste(cntry, "population by year"),
         subtitle = paste("Local currency: x")) +
    
    ## save
    ggsave(filename = file.path("figures",
                                paste(cntry, "_gdp_by_year.png", sep='')), 
           device = "png", width = 15, height = 10)
  
}

```




Now, do the same by plotting gdp. Think: should the gdp calculation go inside the for loop or outside?


All together now:
```{r}

gapminder <- readr::read_csv('https://raw.githubusercontent.com/OHI-Science/data-science-training/master/data/gapminder.csv')

gap_europe <- 

## filter for Europe, calc gdp
gap_europe <- gapminder %>%
  filter(continent == "Europe") %>%
  dplyr::group_by(country) %>%
  dplyr::mutate(gdp = pop * gdpPercap)
  
## vector of countries   
countries_europe <- unique(gap_europe$country)


for (cntry in countries_europe) { # cntry = "Albania"
 
  gap_cntry <- gap_europe %>%
    filter(country == cntry)
  
  ggplot(data = gap_cntry, aes(x = year, y = gdp)) + 
    geom_point() + 
    labs(title = paste(cntry, "GDP by year"),
         subtitle = paste("Local currency: x")) +
    ## save
    ggsave(filename = file.path("figures",
                                paste(cntry, "_gdp_by_year.png", sep='')), 
           device = "png", width = 15, height = 10)
  
}




```

## Your turn

Plot gdp for just Asia. What would you do differently? What goes inside the for loop?

Save the file with the label "Albania GDP 1950-2007"



## conditional statements with `if` and `else`

Often when we're coding we want to control the flow of our actions. This can be done
by setting actions to occur only if a condition or a set of conditions are met.
```{r, eval=FALSE}
# if
if (condition is true) {
  do something
}

# if ... else
if (condition is true) {
  do something
} else {  # that is, if the condition is false,
  do something different
}
```

Say, for example, that in addition to saving population figures for all countries, we want to save life expectancy figures for countries in Asia only. 
```{r, eval=FALSE}
dir.create('figures') # this will be: software-carpentry/figures

country_list <- unique(gapminder$country) # ?unique() returns the unique values
country_pop_mean <- data.frame()
for (cntry in country_list) {
  cntry_subset <- subset(gapminder, subset = country == cntry) 
  # plot(cntry_subset$year, cntry_subset$pop)
  # dev.print(pdf, paste0("figures/", cntry,".pdf")) 
  
  pop_mean <- mean(cntry_subset$pop)
  # print(paste('mean pop for', cntry, 'is', pop_mean))
  country_pop_mean <- rbind(country_pop_mean, data.frame(cntry, pop_mean))
  
  ## if Asia, calculate mean(lifeExp)
  if (unique(cntry_subset$continent) == "Asia") { # read: if (the continent is Asia) {then}
    plot(cntry_subset$year, cntry_subset$lifeExp) 
    dev.print(pdf, paste0("figures/", cntry, "_lifeExp.pdf")) # change the filename
  }
} 
```


And if the country is in Africa, let's plot the mean GDP. 
```{r, eval=FALSE}
dir.create('figures') # this will be: software-carpentry/figures

country_list <- unique(gapminder$country) # ?unique() returns the unique values
country_pop_mean <- data.frame()
for (cntry in country_list) {
  cntry_subset <- subset(gapminder, subset = country == cntry) 
  # plot(cntry_subset$year, cntry_subset$pop)
  # dev.print(pdf, paste0("figures/", cntry,".pdf")) 
  
  pop_mean <- mean(cntry_subset$pop)
  # print(paste('mean pop for', cntry, 'is', pop_mean))
  country_pop_mean <- rbind(country_pop_mean, data.frame(cntry, pop_mean))
  
  ## if Asia, calculate mean(lifeExp)
  if (unique(cntry_subset$continent) == "Asia") { # read: if (the continent is Asia) {then}
    plot(cntry_subset$year, cntry_subset$lifeExp) 
    dev.print(pdf, paste0("figures/", cntry, "_lifeExp.pdf")) 
  } else if (unique(cntry_subset$continent) == "Africa") {
    plot(cntry_subset$year, cntry_subset$gdpPercap) 
    dev.print(pdf, paste0("figures/", cntry, "_gdpPercap.pdf")) # change the filename
  }
} 
```


## Importing and Installing

TODO

Remember you'll use `install.packages("package-name-in-quotes")` and then `library(package-name)`, and then you can explore the help or vignettes. And also, of course, Google to see how to use them!

- `readr` to read in .csv files
- `readxl` to read in Excel files
- `stringr` to work with strings
- `lubridate` to work with dates

- `devtools::install_github()`

## Organization and workflows
- source(),
- set up a folder for figs, intermediate analyses, final outputs, figures
- could even do an R package. `devtools`, `roxygen2`. http://r-pkgs.had.co.nz/ 

You'll soon have questions that are outside the scope of this workshop, how do you find answers?

- end with a ton of resources:
https://peerj.com/collections/50-practicaldatascistats/

## Ideas for Extended Analysis 2

- stringr() http://r4ds.had.co.nz/strings.html
