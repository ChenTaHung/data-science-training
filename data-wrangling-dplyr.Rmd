# Data wrangling with dplyr (tidyverse) {#dplyr} 

```{r wrangling1, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(htmltools)
```

TODO!!! this is all piecemeal from different lessons; make sure it all jives. New script for wrangling with gapminder. MAYBE THIS IS JUST DPLYR AND PIPES

## Overview & Resources

- learn dplyr, tidyr with gapminder package
- practice RStudio-GitHub workflow


- cheatsheets


## Tidy Data

Hadley Wickham, RStudio's Chief Scientist, has been building R packages for data wrangling and visualization based on the idea of **tidy data**. Great resources include RStudio's [data wrangling cheatsheet](http://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)  (screenshots below are from this cheatsheet) and [data wrangling webinar](https://www.rstudio.com/resources/webinars/data-wrangling-with-r-and-rstudio/). 

Tidy data has a simple convention: put variables in the columns and observations in the rows.

![](img/tidy_data.png)
</br>
</br>
Our `gapminder` dataset is pretty tidy. This enables you to work with it the way you'd want, for your analyses, plots, etc. 
</br>
</br>
![](img/tidy_img.png) 

Right now we are going to use `dplyr` to wrangle this tidyish data set (the transform part of the cycle), and then come back to tidying messy data using `tidyr` once we've had some fun wrangling. 

![](img/r4ds_data-science.png)

### `dplyr` overview

There are five `dplyr` functions that you will use to do the vast majority of data manipulations:

- **pick observations by their values (`filter()`)**,
    - `r img(src='img/rstudio-cheatsheet-filter.png', width=300)` 
- **pick variables by their names (`select()`)**,
    - `r img(src='img/rstudio-cheatsheet-select.png', width=300)`
- **create new variables with functions of existing variables (`mutate()`)**, 
    - `r img(src='img/rstudio-cheatsheet-mutate.png', width=300)`
- **collapse many values down to a single summary (`summarise()`)**,
    - `r img(src='img/rstudio-cheatsheet-summarise.png', width=300)`
- **reorder the rows (`arrange()`)**



These can all be used in conjunction with `group_by()` which changes the scope of each function from operating on the entire dataset to operating on it group-by-group. These six functions provide the verbs for a language of data manipulation.

All verbs work similarly:

1. The first argument is a data frame.
2. The subsequent arguments describe what to do with the data frame. You can refer to columns in the data frame directly without using `$`.
3. The result is a new data frame.

Together these properties make it easy to chain together multiple simple steps to achieve a complex result.


### setup

We'll do this in a new R script in the `software-carpentry` folder we created this morning. 

**Here's what to do:**

1. Open RStudio
1. Make sure you're in your `software-carpentry` repo (and if not, get there)
1. New File > R Script
1. Save as `gapminder-wrangle.r`

Today's materials are again borrowing from some excellent sources, including:

- Jenny Bryan's lectures from STAT545 at UBC: [Introduction to dplyr](http://stat545.com/block009_dplyr-intro.html)
- Hadley Wickham and Garrett Grolemund's [R for Data Science](http://r4ds.had.co.nz/)
- Software Carpentry's R for reproducible scientific analysis materials: [Dataframe manipulation with dplyr](http://swcarpentry.github.io/r-novice-gapminder/13-dplyr.html)
- First developed for [Software Carpentry at UCSB](http://remi-daigle.github.io/2016-04-15-UCSB/dplyr/)


### install `dplyr` // TODO:: `tidyverse`

Packages are bundles of functions, along with help pages and other goodies that make them easier for others to use, (ie. vignettes). 

So far we've been using packages included in 'base R'; they are 'out-of-the-box' functions. You can also install packages from online. The most traditional is [CRAN, the Comprehensive R Archive Network](https://cran.r-project.org/). This is where you went to download R originally, and will go again to look for updates. 

You don't need to go to CRAN's website to install packages, we can do it from within R with the command `install.packages("package-name-in-quotes")`.
```{r, messages=FALSE}
## from CRAN:
#install.packages("dplyr") ## do this once only to install the package on your computer.
library(dplyr) ## do this every time you restart R and need it 
```

What's the difference between `install.packages()` and `library()`? Why do you need both? Here's my analogy: 

- `install.packages()` is setting up electricity for your house. Just need to do this once (let's ignore monthly bills). 
- `library()` is turning on the lights. You only turn them on when you need them, otherwise it wouldn't be efficient. And when you quit R, it turns the lights off, but the electricity lines are still there. So when you come back, you'll have to turn them on again with `library()`, but you already have your electricity set up.

## Meet your first data.frame: gapminder

We will work with some of the data from the [Gapminder project](http://www.gapminder.org). Have a look at `data/gapminder.csv` by navigating to it in the RStudio file pane and looking at it (RStudio is also a text editor so you can read this file right here). 

```{r, eval=FALSE}
## read gapminder csv
gapminder <- read.csv('data/gapminder.csv')
```

Let's inspect: 
```{r, eval=FALSE}
## explore the gapminder dataset
gapminder # this is super long! Let's inspect in different ways
```

Let's use `head` and `tail`: 
```{r, eval=FALSE}
head(gapminder) # shows first 6
tail(gapminder) # shows last 6

head(gapminder, 10) # shows first X that you indicate
tail(gapminder, 12) # guess what this does!
```

`str()` will provide a sensible description of almost anything: when in doubt, just `str()` some of the recently created objects to get some ideas about what to do next.
```{r, eval=FALSE}
str(gapminder) # ?str - displays the structure of an object
```

`gapminder` is a `data.frame`. We aren't going to get into the other types of data receptacles today ('arrays', 'matrices'), because working with data.frames is what you should primarily use. Why?

- data.frames package related variables neatly together, great for analysis
- most functions, including the latest and greatest packages actually __require__ that your data be in a data.frame
- data.frames can hold variables of different flavors such as
    - character data (country or continent names; "Factors") 
    - quantitative data (years, population; "Integers (int)" or "Numeric (num)")
    - categorical information (male vs. female)
  
We can also see the `gapminder` variable in RStudio's Environment pane (top right)

More ways to learn basic info on a data.frame. 
```{r, eval=FALSE}
names(gapminder)
dim(gapminder)    # ?dim dimension
ncol(gapminder)   # ?ncol number of columns; same as dim(gapminder)[1]
nrow(gapminder)   # ?nrow number of rows; same as dim(gapminder)[2]
```

We can combine using `c()` to reverse-engineer `dim()`! Just a side-note here, but I wanted to introduce you to `c()`: we'll use it later.
```{r, eval=FALSE}
c(nrow(gapminder), ncol(gapminder)) # ?c combines values into a vector or list. 
```

A statistical overview can be obtained with `summary()`
```{r, eval=FALSE}
summary(gapminder)
```

### Look at the variables inside a data.frame

To specify a single variable from a data.frame, use the dollar sign `$`. The `$` operator is a way to extract of replace parts of an object--check out the help menu for `$`. It's a common operator you'll see in R. 

```{r, eval=FALSE}
gapminder$lifeExp # very long! hard to make sense of...
head(gapminder$lifeExp) # can do the same tests we tried before
str(gapminder$lifeExp) # it is a single numeric vector
summary(gapminder$lifeExp) # same information, just formatted slightly differently
```


## Use `dplyr::filter()` to subset data row-wise (observations).

You will want to isolate bits of your data; maybe you want to just look at a single country or a few years. R calls this subsetting. There are several ways to do this. We'll go through a few options in base R so that you're familiar with them, and know how to read them. But then we'll move on to a new, better, intuitive, and game changing way with the `dplyr` package afterwards.

First let's read in the gapminder data. Earlier, we read in a `.csv` of the gapminder data. But Jenny Bryan has also released this as an R package, so you could also install it from CRAN and load it into as extra practice for loading packages.
```{r}
# install.packages('gapminder') # instead of reading in the csv
library(gapminder) # this is the package name
```

```{r, eval=FALSE}
str(gapminder) # there's still a data frame named 'gapminder'
```

`filter()` takes logical expressions and returns the rows for which all are `TRUE`. 

Visually, we are doing this (thanks RStudio for your [cheatsheet](http://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)): 

![](img/rstudio-cheatsheet-filter.png)

```{r, eval=FALSE}
filter(gapminder, lifeExp < 29)
filter(gapminder, country == "Mexico")
filter(gapminder, country %in% c("Mexico", "Afghanistan"))
```

Compare with some base R code to accomplish the same things
```{r, eval = FALSE}
gapminder[gapminder$lifeExp < 29, ] ## repeat `gapminder`, [i, j] indexing is distracting
subset(gapminder, country == "Mexico") ## almost same as filter ... but wait ...
```

### Your turn

visualize with ggplot2

## Meet the new pipe operator

Before we go any further, we should exploit the new pipe operator that `dplyr` imports from the [`magrittr`](https://github.com/smbache/magrittr) package by Stefan Bache. **This is going to change your data analytical life**. You no longer need to enact multi-operation commands by nesting them inside each other. This new syntax leads to code that is much easier to write and to read.

Here's what it looks like: `%>%`. The RStudio keyboard shortcut: Ctrl + Shift + M (Windows), Cmd + Shift + M (Mac).

Let's demo then I'll explain:
```{r, eval=FALSE}
gapminder %>% head()
```

This is equivalent to `head(gapminder)`. This pipe operator takes the thing on the left-hand-side and __pipes__ it into the function call on the right-hand-side -- literally, drops it in as the first argument.

Never fear, you can still specify other arguments to this function! To see the first 3 rows of Gapminder, we could say `head(gapminder, 3)` or this:
```{r, eval=FALSE}
gapminder %>% head(3)
```

**I've advised you to think "gets" whenever you see the assignment operator, `<-`. Similary, you should think "and then" whenever you see the pipe operator, `%>%`.**

You are probably not impressed yet, but the magic will soon happen.

Fun break: check out [this gif about it from Twitter](https://twitter.com/backerman150/status/926479565869993984).

## Use `dplyr::select()` to subset data column-wise (variables)

Back to `dplyr` ...

Use `select()` to subset the data on variables or columns. 

Visually, we are doing this (thanks RStudio for your [cheatsheet](http://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)): 

![](img/rstudio-cheatsheet-select.png)

Here's a conventional call:

```{r, eval=FALSE}
select(gapminder, year, lifeExp) 
```

But using what we just learned, with a pipe, we can do this:
```{r, eval=FALSE}
gapminder %>% select(year, lifeExp)
```

Let's write it again but using multiple lines so it's nicer to read. And let's add a second pipe operator to pipe through `head`:
```{r, eval=FALSE}
gapminder %>%
  select(year, lifeExp) %>%
  head(4)
```
Think: "Take `gapminder`, then select the variables year and lifeExp, then show the first 4 rows."

### Revel in the convenience
Let's do a little analysis where we calculate the mean gdp for Cambodia. 

Here's the gapminder data for Cambodia, but only certain variables:
```{r, eval=FALSE}
gapminder %>%
  filter(country == "Cambodia") %>%
  # select(country, year, pop, gdpPercap) ## entering 4 of the 6 columns is tedious
  select(-continent, -lifeExp) # you can use - to deselect columns
```

and what a typical base R call would look like:
```{r, eval=FALSE}
gapminder[gapminder$country == "Cambodia", c("country", "year", "pop", "gdpPercap")]
```

or, possibly?, a nicer look using base R's `subset()` function:
```{r, eval=FALSE}
subset(gapminder, country == "Cambodia", select = c(country, year, pop, gdpPercap))
```

## Use `mutate()` to add new variables

Imagine we wanted to recover each country's GDP. After all, the Gapminder data has a variable for population and GDP per capita. Let's add a new column and multiply them together.

Visually, we are doing this (thanks RStudio for your [cheatsheet](http://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)): 

![](img/rstudio-cheatsheet-mutate.png)

```{r, eval=FALSE}
gapminder %>%
  mutate(gdp = pop * gdpPercap)
```

> Exercise: add this new gdp column to our Cambodia example above.

```{r, eval=FALSE}
# Solution (no peeking!)
gapminder %>%
  filter(country == "Cambodia") %>%
  select(-continent, -lifeExp) %>%
  mutate(gdp = pop * gdpPercap)
```

## `group_by` and `summarize` to operate on groups
Great! And now we want to calculate the mean gdp across all years (Let's pretend that's a good idea statistically) 

Visually, we are doing this (thanks RStudio for your [cheatsheet](http://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)): 
 
![](img/rstudio-cheatsheet-summarise.png)

```{r, eval=FALSE}
gapminder %>%
  filter(country == "Cambodia") %>%
  select(-continent, -lifeExp) %>%
  mutate(gdp = pop * gdpPercap) %>%
  group_by(country) %>%
  summarize(mean_gdp = mean(gdp)) %>%
  ungroup() # if you use group_by, also use ungroup() to save heartache later
```
<!---

## Remember our for loop?

And how would you then do this for every country, not just Cambodia? Well, yesterday we would have been thinking about putting this whole analysis inside a for loop, replacing "Cambodia" with a new name each time we iterated through the loop. But today, we have it already, just need to *delete* one line from our analysis--we don't need to filter out Cambodia anymore!! 

--->

Visually, we are doing this (thanks RStudio for your [cheatsheet](http://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)): 
 
![](img/rstudio-cheatsheet-group_by.png)

```{r, eval=FALSE}
gapminder %>%
  select(-continent, -lifeExp) %>%
  mutate(gdp = pop * gdpPercap) %>%
  group_by(country) %>%
  summarize(mean_gdp = mean(gdp)) %>%
  ungroup() # if you use group_by, also use ungroup() to save heartache later
```

So we have done a pretty incredible amount of work in a few lines. Our whole analysis is this. Imagine the possibilities from here. It's very readable: you see the data as the first thing, it's not nested. Then, you can read the verbs. This is the whole thing: 

```{r, eval=FALSE}
library(dplyr)
library(gapminder)

gapminder %>% 
  select(-continent, -lifeExp) %>%
  mutate(gdp = pop * gdpPercap) %>%
  group_by(country) %>%
  summarize(mean_gdp = mean(gdp)) %>%
  ungroup() # if you use group_by, also use ungroup() to save heartache later
```

(In base-R, this would be a nightmare to read, and you would also have to make many temporary variables since you couldn't use the %>% operator. Have a look at this blog to get an idea: [How dplyr replaced my most common R idioms](http://www.statsblogs.com/2014/02/10/how-dplyr-replaced-my-most-common-r-idioms/)).

> Exercise: with your neighbor, find the maximum life expectancy for countries in Asia. What is the earliest year you enounter? The latest? Hint: you can use or `base::max` and `dplyr::arrange()`...

```{r, eval=FALSE}
## possible result--no peeking!!
gapminder %>%
  filter(continent == 'Asia') %>%
  group_by(country) %>%
  filter(lifeExp == max(lifeExp)) %>%
  arrange(desc(year))
```

### TODO: variable classes?

Let's explore a numeric variable: life expectancy.
```{r, eval=FALSE}
## explore numeric variable
summary(gapminder$lifeExp)
hist(gapminder$lifeExp)
```

Let's explore a categorical variable (stored as a *factor* in R): continent.
```{r, eval=FALSE}
## explore factor variable
summary(gapminder$continent)
levels(gapminder$continent)
nlevels(gapminder$continent)
hist(gapminder$continent) # whaaaa!?
```
This error is because of what factors are 'under the hood': R is really storing integer codes 1, 2, 3 here, but represent them as text to us. Factors can be problematic to us because of this, but you can learn to navigate with them. There are resources to learn how to [properly care and feed for factors](http://stat545.com/block014_factors.html).

One thing you'll learn is how to visualize factors with which functions/packages.
```{r, eval=FALSE}
class(gapminder$continent) # ?class returns the class type of the object
table(gapminder$continent) # ?table builds a table based on factor levels 
class(table(gapminder$continent)) # this has morphed the factor...
hist(table(gapminder$continent)) # so we can plot!
```
I don't want us to get too bogged down with what's going on with `table()` and plotting factors, but I want to expose you to these situations because you will encounter them. Googling the error messages you get, and knowing how to look for good responses is a critical skill. (I tend to look for responses from stackoverflow.com that are recent and have green checks, and ignore snarky comments). 

> Exercise with your neighbor: Explore `gapminder$gdpPercap`. What kind of data is it? So which commands do you use? 




