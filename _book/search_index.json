[
["wrangling.html", "Chapter 7 Data wrangling with the tidyverse 7.1 Overview &amp; Resources 7.2 Tidy Data 7.3 dplyr overview 7.4 Meet your first data.frame: gapminder 7.5 Use dplyr::filter() to subset data row-wise (observations). 7.6 Meet the new pipe operator 7.7 Use dplyr::select() to subset data column-wise (variables) 7.8 Revel in the convenience 7.9 Use mutate() to add new variables 7.10 group_by and summarize 7.11 TODO: variable classes? 7.12 tidyr overview 7.13 From wide to long format with gather() 7.14 From long to intermediate format with spread() 7.15 clean up and save your .r script 7.16 Other tidyr awesomeness 7.17 Importing data 7.18 Other links 7.19 Troubleshooting", " Chapter 7 Data wrangling with the tidyverse TODO!!! this is all piecemeal from different lessons; make sure it all jives 7.1 Overview &amp; Resources learn dplyr, tidyr with gapminder package practice RStudio-GitHub workflow cheatsheets 7.2 Tidy Data Hadley Wickham, RStudio’s Chief Scientist, has been building R packages for data wrangling and visualization based on the idea of tidy data. Great resources include RStudio’s data wrangling cheatsheet (screenshots below are from this cheatsheet) and data wrangling webinar. Tidy data has a simple convention: put variables in the columns and observations in the rows. Our gapminder dataset is pretty tidy. This enables you to work with it the way you’d want, for your analyses, plots, etc. Right now we are going to use dplyr to wrangle this tidyish data set (the transform part of the cycle), and then come back to tidying messy data using tidyr once we’ve had some fun wrangling. 7.2.1 setup We’ll do this in a new R script in the software-carpentry folder we created this morning. Here’s what to do: Open RStudio Make sure you’re in your software-carpentry repo (and if not, get there) New File &gt; R Script Save as gapminder-wrangle.r Today’s materials are again borrowing from some excellent sources, including: Jenny Bryan’s lectures from STAT545 at UBC: Introduction to dplyr Hadley Wickham and Garrett Grolemund’s R for Data Science Software Carpentry’s R for reproducible scientific analysis materials: Dataframe manipulation with dplyr First developed for Software Carpentry at UCSB 7.3 dplyr overview There are five dplyr functions that you will use to do the vast majority of data manipulations: pick observations by their values (filter()), pick variables by their names (select()), create new variables with functions of existing variables (mutate()), collapse many values down to a single summary (summarise()), reorder the rows (arrange()) These can all be used in conjunction with group_by() which changes the scope of each function from operating on the entire dataset to operating on it group-by-group. These six functions provide the verbs for a language of data manipulation. All verbs work similarly: The first argument is a data frame. The subsequent arguments describe what to do with the data frame. You can refer to columns in the data frame directly without using $. The result is a new data frame. Together these properties make it easy to chain together multiple simple steps to achieve a complex result. 7.3.1 install dplyr // TODO:: tidyverse Packages are bundles of functions, along with help pages and other goodies that make them easier for others to use, (ie. vignettes). So far we’ve been using packages included in ‘base R’; they are ‘out-of-the-box’ functions. You can also install packages from online. The most traditional is CRAN, the Comprehensive R Archive Network. This is where you went to download R originally, and will go again to look for updates. You don’t need to go to CRAN’s website to install packages, we can do it from within R with the command install.packages(&quot;package-name-in-quotes&quot;). ## from CRAN: #install.packages(&quot;dplyr&quot;) ## do this once only to install the package on your computer. library(dplyr) ## do this every time you restart R and need it ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union What’s the difference between install.packages() and library()? Why do you need both? Here’s my analogy: install.packages() is setting up electricity for your house. Just need to do this once (let’s ignore monthly bills). library() is turning on the lights. You only turn them on when you need them, otherwise it wouldn’t be efficient. And when you quit R, it turns the lights off, but the electricity lines are still there. So when you come back, you’ll have to turn them on again with library(), but you already have your electricity set up. 7.4 Meet your first data.frame: gapminder We will work with some of the data from the Gapminder project. Have a look at data/gapminder.csv by navigating to it in the RStudio file pane and looking at it (RStudio is also a text editor so you can read this file right here). ## read gapminder csv gapminder &lt;- read.csv(&#39;data/gapminder.csv&#39;) Let’s inspect: ## explore the gapminder dataset gapminder # this is super long! Let&#39;s inspect in different ways Let’s use head and tail: head(gapminder) # shows first 6 tail(gapminder) # shows last 6 head(gapminder, 10) # shows first X that you indicate tail(gapminder, 12) # guess what this does! str() will provide a sensible description of almost anything: when in doubt, just str() some of the recently created objects to get some ideas about what to do next. str(gapminder) # ?str - displays the structure of an object gapminder is a data.frame. We aren’t going to get into the other types of data receptacles today (‘arrays’, ‘matrices’), because working with data.frames is what you should primarily use. Why? data.frames package related variables neatly together, great for analysis most functions, including the latest and greatest packages actually require that your data be in a data.frame data.frames can hold variables of different flavors such as character data (country or continent names; “Factors”) quantitative data (years, population; “Integers (int)” or “Numeric (num)”) categorical information (male vs. female) We can also see the gapminder variable in RStudio’s Environment pane (top right) More ways to learn basic info on a data.frame. names(gapminder) dim(gapminder) # ?dim dimension ncol(gapminder) # ?ncol number of columns; same as dim(gapminder)[1] nrow(gapminder) # ?nrow number of rows; same as dim(gapminder)[2] We can combine using c() to reverse-engineer dim()! Just a side-note here, but I wanted to introduce you to c(): we’ll use it later. c(nrow(gapminder), ncol(gapminder)) # ?c combines values into a vector or list. A statistical overview can be obtained with summary() summary(gapminder) 7.4.1 Look at the variables inside a data.frame To specify a single variable from a data.frame, use the dollar sign $. The $ operator is a way to extract of replace parts of an object–check out the help menu for $. It’s a common operator you’ll see in R. gapminder$lifeExp # very long! hard to make sense of... head(gapminder$lifeExp) # can do the same tests we tried before str(gapminder$lifeExp) # it is a single numeric vector summary(gapminder$lifeExp) # same information, just formatted slightly differently 7.5 Use dplyr::filter() to subset data row-wise (observations). You will want to isolate bits of your data; maybe you want to just look at a single country or a few years. R calls this subsetting. There are several ways to do this. We’ll go through a few options in base R so that you’re familiar with them, and know how to read them. But then we’ll move on to a new, better, intuitive, and game changing way with the dplyr package afterwards. First let’s read in the gapminder data. Earlier, we read in a .csv of the gapminder data. But Jenny Bryan has also released this as an R package, so you could also install it from CRAN and load it into as extra practice for loading packages. # install.packages(&#39;gapminder&#39;) # instead of reading in the csv library(gapminder) # this is the package name str(gapminder) # there&#39;s still a data frame named &#39;gapminder&#39; filter() takes logical expressions and returns the rows for which all are TRUE. Visually, we are doing this (thanks RStudio for your cheatsheet): filter(gapminder, lifeExp &lt; 29) filter(gapminder, country == &quot;Mexico&quot;) filter(gapminder, country %in% c(&quot;Mexico&quot;, &quot;Afghanistan&quot;)) Compare with some base R code to accomplish the same things gapminder[gapminder$lifeExp &lt; 29, ] ## repeat `gapminder`, [i, j] indexing is distracting subset(gapminder, country == &quot;Mexico&quot;) ## almost same as filter ... but wait ... 7.5.1 Your turn visualize with ggplot2 7.6 Meet the new pipe operator Before we go any further, we should exploit the new pipe operator that dplyr imports from the magrittr package by Stefan Bache. This is going to change your data analytical life. You no longer need to enact multi-operation commands by nesting them inside each other. This new syntax leads to code that is much easier to write and to read. Here’s what it looks like: %&gt;%. The RStudio keyboard shortcut: Ctrl + Shift + M (Windows), Cmd + Shift + M (Mac). Let’s demo then I’ll explain: gapminder %&gt;% head() This is equivalent to head(gapminder). This pipe operator takes the thing on the left-hand-side and pipes it into the function call on the right-hand-side – literally, drops it in as the first argument. Never fear, you can still specify other arguments to this function! To see the first 3 rows of Gapminder, we could say head(gapminder, 3) or this: gapminder %&gt;% head(3) I’ve advised you to think “gets” whenever you see the assignment operator, &lt;-. Similary, you should think “and then” whenever you see the pipe operator, %&gt;%. You are probably not impressed yet, but the magic will soon happen. 7.7 Use dplyr::select() to subset data column-wise (variables) Back to dplyr … Use select() to subset the data on variables or columns. Visually, we are doing this (thanks RStudio for your cheatsheet): Here’s a conventional call: select(gapminder, year, lifeExp) But using what we just learned, with a pipe, we can do this: gapminder %&gt;% select(year, lifeExp) Let’s write it again but using multiple lines so it’s nicer to read. And let’s add a second pipe operator to pipe through head: gapminder %&gt;% select(year, lifeExp) %&gt;% head(4) Think: “Take gapminder, then select the variables year and lifeExp, then show the first 4 rows.” 7.8 Revel in the convenience Let’s do a little analysis where we calculate the mean gdp for Cambodia. Here’s the gapminder data for Cambodia, but only certain variables: gapminder %&gt;% filter(country == &quot;Cambodia&quot;) %&gt;% # select(country, year, pop, gdpPercap) ## entering 4 of the 6 columns is tedious select(-continent, -lifeExp) # you can use - to deselect columns and what a typical base R call would look like: gapminder[gapminder$country == &quot;Cambodia&quot;, c(&quot;country&quot;, &quot;year&quot;, &quot;pop&quot;, &quot;gdpPercap&quot;)] or, possibly?, a nicer look using base R’s subset() function: subset(gapminder, country == &quot;Cambodia&quot;, select = c(country, year, pop, gdpPercap)) 7.9 Use mutate() to add new variables Imagine we wanted to recover each country’s GDP. After all, the Gapminder data has a variable for population and GDP per capita. Let’s add a new column and multiply them together. Visually, we are doing this (thanks RStudio for your cheatsheet): gapminder %&gt;% mutate(gdp = pop * gdpPercap) Exercise: add this new gdp column to our Cambodia example above. # Solution (no peeking!) gapminder %&gt;% filter(country == &quot;Cambodia&quot;) %&gt;% select(-continent, -lifeExp) %&gt;% mutate(gdp = pop * gdpPercap) 7.10 group_by and summarize Great! And now we want to calculate the mean gdp across all years (Let’s pretend that’s a good idea statistically) Visually, we are doing this (thanks RStudio for your cheatsheet): gapminder %&gt;% filter(country == &quot;Cambodia&quot;) %&gt;% select(-continent, -lifeExp) %&gt;% mutate(gdp = pop * gdpPercap) %&gt;% group_by(country) %&gt;% summarize(mean_gdp = mean(gdp)) %&gt;% ungroup() # if you use group_by, also use ungroup() to save heartache later Visually, we are doing this (thanks RStudio for your cheatsheet): gapminder %&gt;% select(-continent, -lifeExp) %&gt;% mutate(gdp = pop * gdpPercap) %&gt;% group_by(country) %&gt;% summarize(mean_gdp = mean(gdp)) %&gt;% ungroup() # if you use group_by, also use ungroup() to save heartache later So we have done a pretty incredible amount of work in a few lines. Our whole analysis is this. Imagine the possibilities from here. It’s very readable: you see the data as the first thing, it’s not nested. Then, you can read the verbs. This is the whole thing: library(dplyr) library(gapminder) gapminder %&gt;% select(-continent, -lifeExp) %&gt;% mutate(gdp = pop * gdpPercap) %&gt;% group_by(country) %&gt;% summarize(mean_gdp = mean(gdp)) %&gt;% ungroup() # if you use group_by, also use ungroup() to save heartache later (In base-R, this would be a nightmare to read, and you would also have to make many temporary variables since you couldn’t use the %&gt;% operator. Have a look at this blog to get an idea: How dplyr replaced my most common R idioms). Exercise: with your neighbor, find the maximum life expectancy for countries in Asia. What is the earliest year you enounter? The latest? Hint: you can use or base::max and dplyr::arrange()… ## possible result--no peeking!! gapminder %&gt;% filter(continent == &#39;Asia&#39;) %&gt;% group_by(country) %&gt;% filter(lifeExp == max(lifeExp)) %&gt;% arrange(desc(year)) 7.11 TODO: variable classes? Let’s explore a numeric variable: life expectancy. ## explore numeric variable summary(gapminder$lifeExp) hist(gapminder$lifeExp) Let’s explore a categorical variable (stored as a factor in R): continent. ## explore factor variable summary(gapminder$continent) levels(gapminder$continent) nlevels(gapminder$continent) hist(gapminder$continent) # whaaaa!? This error is because of what factors are ‘under the hood’: R is really storing integer codes 1, 2, 3 here, but represent them as text to us. Factors can be problematic to us because of this, but you can learn to navigate with them. There are resources to learn how to properly care and feed for factors. One thing you’ll learn is how to visualize factors with which functions/packages. class(gapminder$continent) # ?class returns the class type of the object table(gapminder$continent) # ?table builds a table based on factor levels class(table(gapminder$continent)) # this has morphed the factor... hist(table(gapminder$continent)) # so we can plot! I don’t want us to get too bogged down with what’s going on with table() and plotting factors, but I want to expose you to these situations because you will encounter them. Googling the error messages you get, and knowing how to look for good responses is a critical skill. (I tend to look for responses from stackoverflow.com that are recent and have green checks, and ignore snarky comments). Exercise with your neighbor: Explore gapminder$gdpPercap. What kind of data is it? So which commands do you use? 7.12 tidyr overview Often, data must be reshaped for it to become tidy data. What does that mean? There are four main verbs we’ll use, which are essentially pairs of opposites: turn columns into rows (gather()), turn rows into columns (spread()), turn a character column into multiple columns (separate()), turn multiple character columns into a single column (unite()) You use spread() and gather() to transform or reshape data between ‘wide’ to ‘long’ formats. ‘long’ format is the tidy data we are after, where: each column is a variable each row is an observation In the ‘long’ format, you usually have 1 column for the observed variable and the other columns are ID variables. For the ‘wide’ format each row is often a site/subject/patient and you have multiple observation variables containing the same type of data. These can be either repeated observations over time, or observation of multiple variables (or a mix of both). Data input may be simpler or some other applications may prefer the ‘wide’ format. However, many of R‘s functions have been designed assuming you have ’long’ format data. These data formats mainly affect readability. For humans, the wide format is often more intuitive since we can often see more of the data on the screen due to it’s shape. However, the long format is more machine readable and is closer to the formating of databases. The ID variables in our dataframes are similar to the fields in a database and observed variables are like the database values. Question: Is gapminder a purely long, purely wide, or some intermediate format? Sometimes, as with the gapminder dataset, we have multiple types of observed data. It is somewhere in between the purely ‘long’ and ‘wide’ data formats: 3 “ID variables” (continent, country, year) 3 “Observation variables” (pop,lifeExp,gdpPercap). It’s pretty common to have data in this intermediate format in most cases despite not having ALL observations in 1 column, since all 3 observation variables have different units. But we can play with switching it to long format and wide to show what that means (i.e. long would be 4 ID variables and 1 Observation variable). Note: Generally, mathematical operations are better in long format, although some plotting functions actually work better with wide format. 7.12.1 Install tidyr, investigate gapminder data First install and load tidyr: #install.packages(&quot;tidyr&quot;) library(&quot;tidyr&quot;) # warning messages are OK 7.13 From wide to long format with gather() We’ve been working with pretty tidy data. So for practice, now let’s work with these data in a wider format, maybe the way you or your colleague entered it in a spreadsheet. We’ll work with it to get it back to the way we like it. gap_wide &lt;- read.csv(&#39;data/gapminder_wide.csv&#39;) head(gap_wide) str(gap_wide) While wide format is nice for data entry, it’s not nice for calculations. What if you were asked for the mean population after 1990 in Algeria? Possible, but ugly. Let’s tidy it back to the intermediate format we’ve been using. Question: let’s talk this through together. If we’re trying to turn the gap_wide format into gapminder format, what structure does it have that we like? And that we want to change? We like the continent and country columns. We won’t want to change those. For long format, we’d want just 1 column identifying the variable name (tidyr calls this a ‘key’), and 1 column for the data (tidyr calls this the ’value’). For intermediate format, we’d want 3 columns for gdpPercap, lifeExp, and pop. We would like year as a separate column. Let’s get it to long format. We’ll have to do this in 2 steps. The first step is to take all of those column names and make them a variable in a new column, and transfer the values into another column. Let’s have a look at gather()’s help: ?gather Question: What is our key-value pair? We need to name two new variables in the key-value pair, one for the key, one for the value. Let’s name them obstype_year and obs_value. Here’s the start of what we’ll do: gap_long &lt;- gap_wide %&gt;% gather(key = obstype_year, value = obs_values) str(gap_long) head(gap_long) tail(gap_long) So this has reshaped our dataframe, but really not how we wanted. Very important to check, and listen to that warning message–dropping attributes seems very suspicious. Like suspenders. What went wrong? Notice that it didn’t know that we wanted to keep continent and country untouched; we need to give it more information about which columns we want reshaped. We can do this in several ways. One way: identify the column numbers you want to use. Not ideal because column numbers could change, but it does exactly what we want! And illustrates it nicely. gap_long &lt;- gap_wide %&gt;% gather(key = obstype_year, value = obs_values, 3:38) # could also do -1, -2: &#39;not column one, not column two str(gap_long) head(gap_long) tail(gap_long) Better way: identify the columns by name. Listing them out by explicit name can be a good approach if there are a few. But I’m not going to list them out here, and way too much potential for error if you tried gdpPercap_1952, gdpPercap_1957, gdpPercap_1962… So let’s use some of dplyr’s awesome helper functions. gap_long &lt;- gap_wide %&gt;% gather(key = obstype_year, value = obs_values, dplyr::starts_with(&#39;pop&#39;), dplyr::starts_with(&#39;lifeExp&#39;), dplyr::starts_with(&#39;gdpPercap&#39;)) str(gap_long) head(gap_long) tail(gap_long) Success! And you could also do it this way. gap_long &lt;- gap_wide %&gt;% gather(key = obstype_year, value = obs_values, -continent, -country) str(gap_long) head(gap_long) tail(gap_long) To recap: Inside gather() we first name the new column for the new ID variable (obstype_year), the name for the new amalgamated observation variable (obs_value), then the names of the old observation variable. We could have typed out all the observation variables, but as in the select() function (see dplyr lesson), we can use the starts_with() argument to select all variables that starts with the desired character string. Gather also allows the alternative syntax of using the - symbol to identify which variables are not to be gathered (i.e. ID variables) OK, but we’re not done yet. obstype_year actually contains 2 pieces of information, the observation type (pop,lifeExp, or gdpPercap) and the year. We can use the separate() function to split the character strings into multiple variables ?separate –&gt; we’ll tell it which column we want separated, name new columns that we want to create, and tell it what we want it to separate by. Since the obstype_year variable has observation types and years separated by a _, we’ll use that. gap_long &lt;- gap_wide %&gt;% gather(key = obstype_year, value = obs_values, -continent, -country) %&gt;% separate(obstype_year, into = c(&#39;obs_type&#39;,&#39;year&#39;), sep=&quot;_&quot;) str(gap_long) head(gap_long) tail(gap_long) Excellent. This is long format: every row is a unique observation. Yay! Exercise: Using gap_long, calculate the mean life expectancy, population, and gdpPercap for each continent. Hint: use the group_by() and summarize() functions we learned in the dplyr lesson # solution (no peeking!) gap_long %&gt;% group_by(continent, obs_type) %&gt;% summarize(means = mean(obs_values)) 7.14 From long to intermediate format with spread() Now just to double-check our work, let’s use the opposite of gather() to spread our observation variables back to the original format with the aptly named spread(). You pass spread() the key and value pair, which is now obs_type and obs_values. gap_normal &lt;- gap_long %&gt;% spread(obs_type, obs_values) dim(gap_normal) dim(gapminder) names(gap_normal) names(gapminder) Now we’ve got an intermediate dataframe gap_normal with the same dimensions as the original gapminder, but the order of the variables is different. Let’s fix that before checking if they are all.equal(). Exercise: reorder the columns in gap_normal to match gapminder. # Solution, no peeking! # one way with dplyr (also nice because can chain this from gap_normal creation) gap_normal &lt;- gap_normal %&gt;% select(country, continent, year, lifeExp, pop, gdpPercap) # another way with base R gap_normal &lt;- gap_normal[,names(gapminder)] Now let’s check if they are all.equal (?all.equal) is a handy test all.equal(gap_normal,gapminder) head(gap_normal) head(gapminder) We’re almost there, the original was sorted by country, continent, then year. gap_normal &lt;- gap_normal %&gt;% arrange(country,continent,year) all.equal(gap_normal,gapminder) str(gap_normal) str(gapminder) Mine shows a slight difference because one is a data.frame and one is a tbl_df, which is similar to a data.frame. We won’t get into this difference now, I fm feeling good atout these data sets! We’ve gone from the longest format back to the intermediate and we didn’t introduce any errors in our code. Exercise: convert gap_long all the way back to gap_wide. Hint: you’ll need to create appropriate labels for all our new variables (time*metric combinations) with tidyr::unite(). # Solution, no peeking: head(gap_long) # remember the columns gap_wide_new &lt;- gap_long %&gt;% # first unite obs_type and year into a new column called var_names. Separate by _ unite(col = var_names, obs_type, year, sep = &quot;_&quot;) %&gt;% # then spread var_names out by key-value pair. spread(key = var_names, value = obs_values) str(gap_wide_new) 7.15 clean up and save your .r script Spend some time cleaning up and saving gapminder-wrangle.r Restart R. In RStudio, use Session &gt; Restart R. Otherwise, quit R with q() and re-launch it. Your final R script could look something like this: ## install, load dplyr #install.packages(&quot;dplyr&quot;) ## do this once only to install the package on your computer. library(dplyr) ## load gapminder library(gapminder) # this is the package name str(gapminder) # there&#39;s still a data frame named &#39;gapminder&#39; ## practice dplyr::filter() filter(gapminder, lifeExp &lt; 29) filter(gapminder, country == &quot;Mexico&quot;) filter(gapminder, country %in% c(&quot;Mexico&quot;, &quot;Afghanistan&quot;)) ## base R alternatives to dplyr::filter() gapminder[gapminder$lifeExp &lt; 29, ] ## repeat `gapminder`, [i, j] indexing is distracting subset(gapminder, country == &quot;Mexico&quot;) ## almost same as filter ... but wait ... ## pipe operator %&gt;% gapminder %&gt;% head # this... head(gapminder) # ...is the same as this! gapminder %&gt;% head(3) # can pass arguments! this... head(gapminder, 3) # ...is the same as this! ## practice dplyr::select() with %&gt;% select(gapminder, year, lifeExp) # this... gapminder %&gt;% select(year, lifeExp) # ...is the same as this! ## practice with %&gt;% chains gapminder %&gt;% select(year, lifeExp) %&gt;% head(4) # doesn&#39;t have to be a dplyr function gapminder %&gt;% filter(country == &quot;Cambodia&quot;) %&gt;% select(-continent, -lifeExp) # same as select(country, year, pop, gdpPercap) # compare to base R, hard to read! gapminder[gapminder$country == &quot;Cambodia&quot;, c(&quot;country&quot;, &quot;year&quot;, &quot;pop&quot;, &quot;gdpPercap&quot;)] subset(gapminder, country == &quot;Cambodia&quot;, select = c(country, year, pop, gdpPercap)) ## dplyr::mutate() adds new columns gapminder %&gt;% filter(country == &quot;Cambodia&quot;) %&gt;% select(-continent, -lifeExp) %&gt;% mutate(gdp = pop * gdpPercap) ## dplyr::summarize() or summarise() adds new column when grouping gapminder %&gt;% filter(country == &quot;Cambodia&quot;) %&gt;% select(-continent, -lifeExp) %&gt;% mutate(gdp = pop * gdpPercap) %&gt;% group_by(country) %&gt;% summarize(mean_gdp = mean(gdp)) %&gt;% ungroup() # if you use group_by, also use ungroup() to save heartache later ## summarize for all countries (replaces our for loop!) gapminder %&gt;% select(-continent, -lifeExp) %&gt;% mutate(gdp = pop * gdpPercap) %&gt;% group_by(country) %&gt;% summarize(mean_gdp = mean(gdp)) %&gt;% ungroup() # if you use group_by, also use ungroup() to save heartache later ## install tidyr install.packages(&quot;tidyr&quot;) library(tidyr) ## load wide data gap_wide &lt;- read.csv(&#39;data/gapminder_wide.csv&#39;) head(gap_wide) str(gap_wide) ## practice tidyr::gather() wide to long gap_long &lt;- gap_wide %&gt;% gather(key = obstype_year, value = obs_values, -continent, -country) # or gap_long &lt;- gap_wide %&gt;% gather(key = obstype_year, value = obs_values, dplyr::starts_with(&#39;pop&#39;), dplyr::starts_with(&#39;lifeExp&#39;), dplyr::starts_with(&#39;gdpPercap&#39;)) # or (but always be wary of numerics because they could change silently) gap_long &lt;- gap_wide %&gt;% gather(key = obstype_year, value = obs_values, 3:38) # could also do -1, -2: &#39;not column one, not column two ## gather() and separate() to create our original gapminder gap_long &lt;- gap_wide %&gt;% gather(key = obstype_year, value = obs_values, -continent, -country) %&gt;% separate(obstype_year, into = c(&#39;obs_type&#39;,&#39;year&#39;), sep=&quot;_&quot;) ## practice: can still do calculations in long format gap_long %&gt;% group_by(continent, obs_type) %&gt;% summarize(means = mean(obs_values)) ## spread() from normal to wide gap_normal &lt;- gap_long %&gt;% spread(obs_type, obs_values) %&gt;% select(country, continent, year, lifeExp, pop, gdpPercap) # or gap_normal &lt;- gap_long %&gt;% spread(obs_type, obs_values) gap_normal &lt;- gap_normal[,names(gapminder)] ## check that all.equal() all.equal(gap_normal,gapminder) ## unite() and spread(): convert gap_long to gap_wide head(gap_long) # remember the columns gap_wide_new &lt;- gap_long %&gt;% # first unite obs_type and year into a new column called var_names. Separate by _ unite(col = var_names, obs_type, year, sep = &quot;_&quot;) %&gt;% # then spread var_names out by key-value pair. spread(key = var_names, value = obs_values) str(gap_wide_new) 7.16 Other tidyr awesomeness complete() 7.17 Importing data We don’t have time to discuss importing data, but here are some packages by Hadley Wickham to explore and use. Remember you’ll use install.packages(&quot;package-name-in-quotes&quot;) and then library(package-name), and then you can explore the help or vignettes. And also, of course, Google to see how to use them! readr to read in .csv files readxl to read in Excel files stringr to work with strings lubridate to work with dates 7.18 Other links Tidying up Data - Env Info - Rmd Data wrangling with dplyr and tidyr - Tyler Clavelle &amp; Dan Ovando - Rmd 7.19 Troubleshooting "]
]
